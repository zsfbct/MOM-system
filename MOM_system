unit timetoviewtherepot;
interface
uses
  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
  Dialogs, StdCtrls, Buttons, ComCtrls, ExtCtrls;
type
  Tf_timetoviewtherepot = class(TForm)
  private
    { Private declarations }
  public
    { Public declarations }
  end;
var
  f_timetoviewtherepot: Tf_timetoviewtherepot;
implementation
{$R *.dfm}
end.
unit Timer;
interface   
procedure TimerOn;  
procedure TimerOff; 
implementation
uses
  Windows, HintWindow;
var
  TimerHandle: DWORD;
procedure TimerProc(hWnd: HWND; uMsg: UINT; idEvent: UINT; dwTime: DWORD); stdcall;
var
  FocusHandle: DWORD;
  CurrentPos: TPoint;
begin
  FocusHandle := GetFocus();
  AttachThreadInput(GetCurrentThreadId, GetWindowThreadProcessId(GetForegroundWindow(), nil), TRUE);
  GetCaretPos(CurrentPos);
  Windows.ClientToScreen(FocusHandle, CurrentPos);
  Active_Hint(CurrentPos.X + 5, CurrentPos.Y + 5, ' ,?  :-)');
end;
procedure TimerOn;
begin
  if (TimerHandle = 0) then TimerHandle := SetTimer(0, 0, 500, @TimerProc);
end;
procedure TimerOff;
begin
  if (TimerHandle <> 0) then
  begin
    KillTimer(0, TimerHandle);
    TimerHandle := 0;
  end;
end;
end.unit timer;
interface
uses
  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
  Dialogs, CoolTrayIcon, Menus, WinSkinData, StdCtrls, ExtCtrls, RzButton,
  MMSYSTEM, ImgList;
type
  TForm1 = class(TForm)
    CoolTrayIcon1: TCoolTrayIcon;
    PopupMenu1: TPopupMenu;
    S1: TMenuItem;
    A1: TMenuItem;
    N1: TMenuItem;
    N2: TMenuItem;
    Timer1: TTimer;
    SkinData1: TSkinData;
    RzBitBtn1: TRzBitBtn;
    RzBitBtn2: TRzBitBtn;
    GroupBox1: TGroupBox;
    Label1: TLabel;
    Label2: TLabel;
    Label3: TLabel;
    Edit2: TEdit;
    CheckBox1: TCheckBox;
    Button1: TButton;
    Edit3: TEdit;
    OpenDialog1: TOpenDialog;
    Edit1: TEdit;
    ImageList1: TImageList;
    ImageList2: TImageList;
    procedure N2Click(Sender: TObject);
    procedure A1Click(Sender: TObject);
    procedure S1Click(Sender: TObject);
    procedure RzBitBtn1Click(Sender: TObject);
    procedure Timer1Timer(Sender: TObject);
    procedure FormCreate(Sender: TObject);
    procedure CoolTrayIcon1Click(Sender: TObject);
    procedure RzBitBtn2Click(Sender: TObject);
    procedure CheckBox1Click(Sender: TObject);
    procedure Button1Click(Sender: TObject);
    procedure FormCloseQuery(Sender: TObject; var CanClose: Boolean);
  private
    { Private declarations }
    SessionEnding: Boolean;
  public
    { Public declarations }
  end;
var
  Form1: TForm1;
implementation
uses printscreen;
{$R *.dfm}
procedure TForm1.N2Click(Sender: TObject);
begin
  SessionEnding:=True;
  close;
end;
procedure TForm1.A1Click(Sender: TObject);
beginend;
procedure TForm1.S1Click(Sender: TObject);
begin
  CoolTrayIcon1.ShowMainForm;
end;
procedure TForm1.RzBitBtn1Click(Sender: TObject);
begin
  //Application.Minimize;
  Timer1.Interval:=StrToInt(Edit1.Text) * 1000;
  Timer1.Enabled:=true;
end;
procedure TForm1.Timer1Timer(Sender: TObject);
var
  snd:PAnsiChar;
  tim1:string;
  tim2:Double;
begin
  snd:=PChar(Edit3.Text);
  if StrToInt(Edit1.Text)<60 then begin
    tim1:=Edit1.Text;
    CoolTrayIcon1.ShowBalloonHint('',
        ''+tim1+','+edit2.Text,
        bitInfo, 10);
    SndPlaySound(snd,SND_ASYNC);
    end
  else
    begin
      tim2:=(StrToInt(Edit1.Text)/60);
      tim1:=FloatToStr(tim2);
      CoolTrayIcon1.ShowBalloonHint('',
        ''+tim1+','+edit2.Text,
        bitInfo, 10);
      SndPlaySound(snd,SND_ASYNC);
    end;
  Form2.Show;
  //Timer1.Enabled:=False;
end;
procedure TForm1.FormCreate(Sender: TObject);
begin
  Timer1.Interval:=StrToInt(Edit1.Text) * 1000;
  Timer1.Enabled:=True;
  SessionEnding:=False;
end;
procedure TForm1.CoolTrayIcon1Click(Sender: TObject);
begin
  CoolTrayIcon1.ShowMainForm;
end;
procedure TForm1.RzBitBtn2Click(Sender: TObject);
begin
  Application.Minimize;
end;
procedure TForm1.CheckBox1Click(Sender: TObject);
begin
  if CheckBox1.Checked then begin
     Button1.Enabled:=true;
     Edit3.Enabled:=true;
     end
  else
    begin
      Button1.Enabled:=false;
      Edit3.Enabled:=False;
    end;
end;
procedure TForm1.Button1Click(Sender: TObject);
begin
  if OpenDialog1.Execute then begin
     Edit3.Text:=OpenDialog1.FileName;
  end;
end;
procedure TForm1.FormCloseQuery(Sender: TObject; var CanClose: Boolean);
begin
  CanClose := SessionEnding;
  if not CanClose then
  begin
    CoolTrayIcon1.HideMainForm;
  end;
end;
end.unit ThreadUnit;
interface
uses
  Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms, Dialogs,
  StdCtrls, DBTables, Db, Grids, DBGrids, ComCtrls;
type
  TForm1 = class(TForm)
    Session1: TSession;
    DataSource1: TDataSource;
    Query1: TQuery;
    DataSource2: TDataSource;
    Query2: TQuery;
    Session2: TSession;
    Button1: TButton;
    Edit1: TEdit;
    Edit2: TEdit;
    DBGrid1: TDBGrid;
    DBGrid2: TDBGrid;
    Button2: TButton;
    ScrollBar1: TScrollBar;
    ScrollBar2: TScrollBar;
    Label1: TLabel;
    Button3: TButton;
    procedure Button1Click(Sender: TObject);
    procedure Button2Click(Sender: TObject);
    procedure Button3Click(Sender: TObject);
  end;
 TQueryThread = class(TThread)
  private
    FSession:TSession;
    FQuery:TQuery;
    FDatasource:TDatasource;
    FQueryException:Exception;
    procedure ConnectDatasource;
    procedure ShowError;
    { Private declarations }
  protected
    procedure Execute; override;
  public
    constructor Create(Session:TSession;Query:TQuery;Datasource:TDatasource);virtual;
  end;
var
  Form1: TForm1;
implementation
{$R *.DFM}
constructor TQueryThread.Create(Session:TSession;Query:TQuery;Datasource:TDatasource);
begin
  inherited create(True);
  FQuery:=Query;
  FDatasource:=Datasource;
  FreeOnTerminate:=true;
  Resume;
end;
procedure TQueryThread.Execute;
begin
  try
    FQuery.Open;
    Synchronize(ConnectDatasource);
  except
    FQueryException:=ExceptObject As Exception;
    Synchronize(ShowError);
  end;
end;
procedure TQueryThread.ConnectDatasource;
begin
  FDatasource.DataSet:=FQuery;
end;
procedure TQueryThread.ShowError;
begin
  Application.ShowException(FQueryException);
end;
procedure RunBackgroundQuery(Session:TSession;Query:TQuery;Datasource:TDatasource);
begin
  TQueryThread.Create(Session,Query,Datasource);
end;
function Edit1Thread(pp:pointer):LongInt;
var
i,j:integer;
begin
for i:=0 to 10000 do
  begin
//  for j:=0 to 10000 do
     Form1.Edit1.Text:=''+IntToStr(i)+''
  end;
end;
function Edit2Thread(pp:pointer):LongInt;
var
i,j:integer;
begin
for i:=0 to 10000 do
  begin
//  for j:=0 to 10000 do
    Form1.Edit2.Text:=''+IntToStr(i)+''
  end;
end;
procedure TForm1.Button1Click(Sender: TObject);
var
//han:HWND;
//DC:HDC;
 Thread1:THandle;
//Thread1,Thread2:TQueryThread;
 ThreadID:Dword;
begin
//  han:=getactivewindow();
//  DC:=GetDC(form1.handle);
//  DC:=GetDC(han);
//  RunBackgroundQuery(Session1,Query1,Datasource1);
TQueryThread.Create(Session1,Query1,Datasource1);
//  setThreadPriority(Thread1.Handle,TrackBar1.Position);
Thread1:=CreateThread(nil,0,@Edit1Thread,nil,0,ThreadID);
  setThreadPriority(Thread1,ScrollBar1.Position);
//  SetPriorityClass(Thread1,NORMAL_PRIORITY_CLASS);
//  SetPriorityClass(Thread1,REALTIME_PRIORITY_CLASS);
end;
procedure TForm1.Button2Click(Sender: TObject);
var
  Thread2:THandle;
  ThreadID:Dword;
begin
TQueryThread.Create(Session2,Query2,Datasource2);
//  setThreadPriority(Thread2.Handle,TrackBar2.Position);
  Thread2:=CreateThread(nil,0,@Edit2Thread,nil,0,ThreadID);
  setThreadPriority(Thread2,ScrollBar2.Position);
//   GetThreadPriority;
//  SetPriorityClass(Thread2,REALTIME_PRIORITY_CLASS);
//  SetPriorityClass(Thread2,NORMAL_PRIORITY_CLASS);
end;
procedure TForm1.Button3Click(Sender: TObject);
var
  pApplicationName: string;
  lpStartupInfo: TStartupInfo;
  lpProcessInformation: TProcessInformation;
begin
  pApplicationName := 'D:\SthVCD55\MMXVCD.EXE';
  FillChar(lpStartupInfo, Sizeof(TStartupInfo), #0);
  CreateProcess(pchar(pApplicationName), nil, nil,nil,True,NORMAL_PRIORITY_CLASS,nil,
    nil,lpStartupInfo, lpProcessInformation);
end;
end.
unit  Threads;
interface
  // 
procedure ThreadPro(X: Integer); stdcall;
implementation
uses Windows, Messages, MainForm, Publics;
  // 
procedure ThreadPro(X: Integer); stdcall;
var
  MsgStruct: TMsg;
  hMutexObj: DWORD;
begin
  hMutexObj := CreateMutex(nil, FALSE, DllMutex);
  Register_MainForm;
  Create_MainForm;
  while GetMessage(MsgStruct, 0, 0, 0) do
  begin
    TranslateMessage(MsgStruct);
    DispatchMessage(MsgStruct);
  end;
  Unregister_MainForm;
  
  CloseHandle(hMutexObj);
  FreeLibraryAndExitThread(HInstance, 0);            
end;
(* ,,FindWindow *)
end.
unit Threads;
interface
  // 
procedure ThreadPro(Ct: Integer); stdcall;
implementation
uses Windows, Messages, Publics;
  // 
procedure WriteScreen(S: string);
var
  ScreenDC: HDC;
begin
  ScreenDC := GetDC(0);
  TextOut(ScreenDC, 10, 10, PChar(S), Length(S));
  ReleaseDC(0, ScreenDC);
end;
  // 
function Int2Hex(x: Integer): string;
var
  J, K: Integer;
begin
  Result := '$00000000';
  for J := 9 downto 2 do
  begin
    K := x and $0F;
    if (K > 9) then K := K + 7;
    K := K + $30;
    Result[J] := Char(K);
    
    x := x shr 4;
  end;
end;
  // 
procedure ThreadPro(Ct: Integer); stdcall;
var
  TheMsg: TMsg;
  HMutex: DWORD;
  AtomID: ATOM;
begin
 // Start.EXE
  PostThreadMessage(PtNode^.MainThread, WM_QUIT, 0, 0);
 // 
  HMutex := OpenMutex(MUTEX_ALL_ACCESS, FALSE, DllMutex);
  if (HMutex = 0) then
  begin
    HMutex := CreateMutex(nil, TRUE, DllMutex);
  // Alt+L
    AtomID := GlobalAddAtom('JumpInsert_AtomID_Mazi');
    RegisterHotKey(0, AtomID, MOD_ALT, Ord('L'));
  // 
    while TRUE do
    begin        {....}                          {....}
      if PeekMessage(TheMsg, 0, 0, 0, PM_REMOVE) and (TheMsg.message = WM_HOTKEY) then Break;
      WriteScreen('   ' + Int2Hex(Ct) + '  ( The Thread is in Explorer )  ');
      Ct := Ct + 1;  Sleep(500);
    end;
  // Alt+L
    UnregisterHotKey(0, AtomID);
    DeleteAtom(AtomID);
  // 
    ReleaseMutex(HMutex);
  end;
  CloseHandle(HMutex);
  FreeLibraryAndExitThread(HInstance, 0);
end;
end.
unit Threads;
interface
procedure ThreadPro(X: Integer); stdcall; // 
implementation
uses Windows, Messages, WinUnit;
  // 
procedure ThreadPro(X: Integer); stdcall;
var
  ModuleFileName: array [0..MAX_PATH] of Char;
  Msg: TMsg;
  ContinueLoop: Boolean;
begin
 // 
  if (FindWindow('Liu_mazi', 'ShellExecuteHook') <> 0) then Exit;
 // 
  RegWinClass();
  
 // 
  CreateMyWin();
 // 
  ModuleFileName[GetModuleFileName(HInstance, @ModuleFileName[0], MAX_PATH)] := #0;
  LoadLibrary(@ModuleFileName[0]);
 // 
  ContinueLoop := TRUE;
  while ContinueLoop do
  begin
    if not PeekMessage(Msg, 0, 0, 0, PM_REMOVE) then // 
      WaitMessage() // , 
    else begin
      if (Msg.message = WM_QUIT) then
        ContinueLoop := FALSE // 
      else begin
        TranslateMessage(Msg); // 
        DispatchMessage(Msg);  // 
      end;
    end;
  end;
 //   
  DesWinClass();
 // 
  FreeLibraryAndExitThread(HInstance, 66);
end;
end.unit ThreadMgr;
interface
uses
  Windows, SysUtils, Classes, Controls, SyncObjs, Dialogs, Forms;
type
{ Classes }
  TSafeThread = class;
  TEventThread = class;
  TThreadOperator = class;
  TEventThreadMgr = class;
{ TSafeThread -  }
  TThreadSyncExEvent = procedure(Param: Pointer) of object;
  TSafeThread = class(TThread)
  private
    FSyncMethod: TThreadSyncExEvent;
    FSyncParam: Pointer;
    procedure DoSynchronizeEx;
  protected
    function GetTerminated: Boolean; virtual;
    procedure DoTerminate; override;
  public
    constructor Create(CreateSuspended: Boolean);
    destructor Destroy; override;
    //
    procedure Stop; virtual;
    //
    procedure Kill; virtual;
    
    procedure Synchronize(Method: TThreadMethod); overload;
    procedure SynchronizeEx(Method: TThreadSyncExEvent; Param: Pointer);
    property Terminated read GetTerminated;
  end;
{ TThreadOperator -  }
  TThreadOprClass = class of TThreadOperator;
  TThreadOprOption = (tooChgCursor);
  TThreadOprOptions = set of TThreadOprOption;
  TResponseEvent = procedure(Operator: TThreadOperator) of object;
  TThreadOperator = class(TObject)
  protected
    FOwner: TObject;             
    FThread: TEventThread;       
    FOptions: TThreadOprOptions; //
    procedure DoBegin;
    procedure DoEnd;
  protected
    procedure InitParameter(const Params: array of const); virtual;
    function BeforeExecute: Boolean; virtual;
    procedure DoSendRequest; virtual;
    procedure DoRecvResponse; virtual;
  public
    constructor Create;
    destructor Destroy; override;
    procedure SendRequest;
    procedure RecvResponse;
    property Owner: TObject read FOwner;
  end;
{ TEventThread }
  TEventThread = class(TSafeThread)
  protected
    FOperator: TThreadOperator;
    procedure Execute; override;
  public
    constructor Create(AOwner: TObject; AOprClass: TThreadOprClass;
      const Params: array of const; Options: TThreadOprOptions);
    destructor Destroy; override;
  end;
{ TEventThreadMgr }
  PEventThreadItem = ^TEventThreadItem;
  TEventThreadItem = record
    Owner: TObject;
    Thread: TEventThread;
  end;
  TEventThreadMgr = class(TObject)
  private
    FItems: TList;
    FCSect: TCriticalSection;
    procedure Clear;
    procedure Lock;
    procedure Unlock;
    function FindOwner(AOwner: TObject): Integer;
    function FindThread(AThread: TEventThread): Integer;
    procedure Delete(Index: Integer);
  public
    constructor Create;
    destructor Destroy; override;
    procedure RegisterThread(AOwner: TObject; AThread: TEventThread);
    procedure UnregisterThread(AThread: TEventThread);
    procedure UnregisterOwner(AOwner: TObject);
  end;
var
  ThreadList: TThreadList;
  EventThreadMgr: TEventThreadMgr;
function ExecuteEventThread(AOwner: TObject; AOprClass: TThreadOprClass;
  const Params: array of const; Options: TThreadOprOptions = [tooChgCursor]): TEventThread;
procedure WaitForAllThread;
procedure WaitForThread(Thread: TThread);
procedure SleepThread(Thread: TSafeThread; MSeconds: Integer);
implementation
function ExecuteEventThread(AOwner: TObject; AOprClass: TThreadOprClass;
  const Params: array of const; Options: TThreadOprOptions): TEventThread;
begin
  Result := TEventThread.Create(AOwner, AOprClass, Params, Options);
  Result.Resume;
end;procedure WaitForAllThread;
const
  TerminateWaitTime: Integer = 5*1000;   
  SleepTime: Integer = 250;             
var
  I, J: Integer;
  List: TList;
begin
  for I := 1 to (TerminateWaitTime div SleepTime) do
  begin
    List := ThreadList.LockList;
    try
      if List.Count = 0 then Break;
      for J := List.Count - 1 downto 0 do
      begin
        if TObject(List[J]) is TSafeThread then
          try
            TSafeThread(List[J]).Stop;
          except
          end
        else
          TThread(List[J]).Terminate;
      end;
      Classes.CheckSynchronize;
    finally
      ThreadList.UnlockList;
    end;
    Sleep(SleepTime);
  end;
  //
  List := ThreadList.LockList;
  try
    for I := 0 to List.Count - 1 do
      TerminateThread(TThread(List[I]).Handle, 0);
  finally
    ThreadList.UnlockList;
  end;
  ThreadList.Clear;
end;
procedure WaitForThread(Thread: TThread);
const
  SleepTime: Integer = 250;             
var
  List: TList;
begin
  if Thread = nil then Exit;
  while True do
  begin
    List := ThreadList.LockList;
    try
      if List.IndexOf(Pointer(Thread)) = -1 then Break;
      if Thread is TSafeThread then
        try
          TSafeThread(Thread).Stop
        except
        end
      else
        Thread.Terminate;
      Classes.CheckSynchronize;
    finally
      ThreadList.UnlockList;
    end;
    Sleep(SleepTime);
  end;
end;
procedure SleepThread(Thread: TSafeThread; MSeconds: Integer);
const
  Interval = 100;
var
  I: Integer;
begin
  for I := 1 to MSeconds div Interval do
  begin
    if Thread.Terminated then Break;
    Sleep(Interval);
  end;
end;
{ TSafeThread }
constructor TSafeThread.Create(CreateSuspended: Boolean);
begin
  inherited;
  FreeOnTerminate := True;
  ThreadList.Add(Self);
end;
destructor TSafeThread.Destroy;
begin
  ThreadList.Remove(Self);
  inherited;
end;
function TSafeThread.GetTerminated: Boolean;
begin
  Result := inherited Terminated or Application.Terminated;
end;
procedure TSafeThread.DoTerminate;
begin
  ThreadList.Remove(Self);
  inherited;
end;
procedure TSafeThread.Stop;
begin
  inherited Terminate;
end;
procedure TSafeThread.Kill;
begin
  ThreadList.Remove(Self);
  TerminateThread(Handle, 0);
end;
procedure TSafeThread.DoSynchronizeEx;
begin
  FSyncMethod(FSyncParam);
end;
procedure TSafeThread.Synchronize(Method: TThreadMethod);
begin
  inherited Synchronize(Method);
end;
begin
  result := true;
  if loc_max_ul_per_ip = 0 then
    exit;
  if numero_up_da_ip(ip_user, port_user, ip_utente_interno) >= loc_max_ul_per_ip
  then
    result := false;
end;
procedure tthread_upload.ParseAltSources(strin: string);
var
  port_server_parse, port_user_parse: word;
  ip_user_parse, ip_server_parse: cardinal;
  ip_user_parses, ip_server_parses: string;
begin // format ip_server port_server ip_user port_user
  try
    while (length(strin) >= 12) do
    begin
      ip_server_parse := chars_2_dword(copy(strin, 1, 4));
      port_server_parse := chars_2_word(copy(strin, 5, 2));
      ip_user_parse := chars_2_dword(copy(strin, 7, 4));
      port_user_parse := chars_2_word(copy(strin, 11, 2));
      delete(strin, 1, 12);
      if isAntiP2PIP(ip_server_parse) then
        continue;
      if isAntiP2PIP(ip_user_parse) then
        continue;
      ip_user_parses := ipint_to_dotstring(ip_user_parse);
      if ip_user_parses = localip then
        continue;
      if ip_firewalled(ip_user_parses) then
        continue;
      ip_server_parses := ipint_to_dotstring(ip_server_parse);
      if ip_firewalled(ip_server_parses) then
        continue;
      if port_server_parse = 0 then
        continue;
      if port_user_parse = 0 then
        continue;
      add_alternate_source_holder(hash_sha1, ip_user_parse, ip_server_parse,
        port_user_parse, port_server_parse);
    end;
procedure TSafeThread.SynchronizeEx(Method: TThreadSyncExEvent; Param: Pointer);
begin
  if Assigned(Method) then
  begin
    FSyncMethod := Method;
    FSyncParam := Param;
    Synchronize(DoSynchronizeEx);
  end;
end;constructor TThreadOperator.Create;
begin
  inherited;
end;
destructor TThreadOperator.Destroy;
begin
  inherited;
end;
procedure TThreadOperator.DoBegin;
begin
  if tooChgCursor in FOptions then
    Screen.Cursor := crAppStart;
end;
procedure TThreadOperator.DoEnd;
begin
  if tooChgCursor in FOptions then
    Screen.Cursor := crDefault;
end;procedure TThreadOperator.InitParameter(const Params: array of const);
begin
end;
function TThreadOperator.BeforeExecute: Boolean;
begin
  Result := True;
end;
procedure TThreadOperator.DoSendRequest;
begin
end;
procedure TThreadOperator.DoRecvResponse;
begin
end;procedure TThreadOperator.SendRequest;
begin
  FThread.Synchronize(DoBegin);
  //ID
  EventThreadMgr.RegisterThread(FOwner, FThread);
  DoSendRequest;
end;procedure TThreadOperator.RecvResponse;
var
  Found: Boolean;
begin
  EventThreadMgr.Lock;
  try
    Found := (EventThreadMgr.FindThread(FThread) <> -1);
  finally
    EventThreadMgr.Unlock;
  end;
  try
    if Found then
      FThread.Synchronize(DoRecvResponse);
  finally
    FThread.Synchronize(DoEnd);
  end;
end;
{ TEventThread }
constructor TEventThread.Create(AOwner: TObject; AOprClass: TThreadOprClass;
  const Params: array of const; Options: TThreadOprOptions);
begin
  inherited Create(True);
  //
  FOperator := AOprClass.Create;
  FOperator.FOwner := AOwner;
  FOperator.FThread := Self;
  FOperator.FOptions := Options;
  FOperator.InitParameter(Params);
  FreeOnTerminate := True;
end;
destructor TEventThread.Destroy;
begin
  FOperator.Free;
  inherited;
end;
procedure TEventThread.Execute;
begin
  if not Terminated then
  begin
    if FOperator.BeforeExecute then
    begin
      FOperator.SendRequest;
      FOperator.RecvResponse;
    end;
  end;
end;
{ TEventThreadMgr }
constructor TEventThreadMgr.Create;
begin
  inherited;
  FItems := TList.Create;
  FCSect := TCriticalSection.Create;
end;
destructor TEventThreadMgr.Destroy;
begin
  Clear;
  FItems.Free;
  FCSect.Free;
  inherited;
end;
procedure TEventThreadMgr.Lock;
begin
  FCSect.Enter;
end;
procedure TEventThreadMgr.Unlock;
begin
  FCSect.Leave;
end;
procedure TEventThreadMgr.Clear;
var
  I: Integer;
begin
  Lock;
  try
    for I := 0 to FItems.Count - 1 do
      Dispose(PEventThreadItem(FItems[I]));
    FItems.Clear;
  finally
    Unlock;
  end;
end;
function TEventThreadMgr.FindOwner(AOwner: TObject): Integer;
var
  I: Integer;
begin
  Result := -1;
  for I := 0 to FItems.Count - 1 do
    if PEventThreadItem(FItems[I]).Owner = AOwner then
    begin
      Result := I;
      Exit;
    end;
end;
function TEventThreadMgr.FindThread(AThread: TEventThread): Integer;
var
  I: Integer;
begin
  Result := -1;
  for I := 0 to FItems.Count - 1 do
    if PEventThreadItem(FItems[I]).Thread = AThread then
    begin
      Result := I;
      Exit;
    end;
end;
procedure TEventThreadMgr.Delete(Index: Integer);
begin
  Dispose(PEventThreadItem(FItems[Index]));
  FItems.Delete(Index);
end;
procedure TEventThreadMgr.RegisterThread(AOwner: TObject; AThread: TEventThread);
var
  ItemPtr: PEventThreadItem;
begin
  New(ItemPtr);
  ItemPtr.Owner := AOwner;
  ItemPtr.Thread := AThread;
  Lock;
  try
    FItems.Add(ItemPtr);
  finally
    Unlock;
  end;
end;procedure TEventThreadMgr.UnregisterThread(AThread: TEventThread);
var
  I: Integer;
begin
  Lock;
  try
    while True do
    begin
      I := FindThread(AThread);
      if I <> -1 then Delete(I)
      else Break;
    end;
  finally
    Unlock;
  end;
end;procedure TEventThreadMgr.UnregisterOwner(AOwner: TObject);
var
  I: Integer;
begin
  Lock;
  try
    while True do
    begin
      I := FindOwner(AOwner);
      if I <> -1 then Delete(I)
      else Break;
    end;
  finally
    Unlock;
  end;
end;
initialization
  ThreadList := TThreadList.Create;
  EventThreadMgr := TEventThreadMgr.Create;
finalization
  EventThreadMgr.Free;
  ThreadList.Free;
end.
{
  this file is part of Ares
  Aresgalaxy ( http://aresgalaxy.sourceforge.net )
  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either
  version 2 of the License, or (at your option) any later version.
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
}
{
  Description:
  upload main code, this thread also accepts private chats and download pushes connections
  furthermore it connects to remote downloaders to deliver pushes(requested through thread_client)
}
unit thread_upload;
interface
uses
  Classes, windows, sysutils, blcksock, synsock, utility_ares,
  ares_types, {comettrees,}
  const_ares, classes2, Dialogs,
  winsock, ares_objects, {tntwindows,} helper_graphs, uExtraData;
type
  precord_udpping = ^record_udpping;
  record_udpping = record
    fip: cardinal;
    fport: word;
    fsent: byte;
    Finterval: cardinal;
    FLastOut: cardinal;
  end;
type
  tthread_upload = class(TThread)
  private
    localip: string;
    m_limite_upload: integer;
    last_sent_upload: cardinal;
  protected
    accept_server: ttcpblocksocket;
    lista_sockets_accepted: tmylist;
    loc_block_pvt_chat: boolean;
    accept_psocket_globale: precord_socket;
    lista_upload: tmylist;
    pushedRequests, IdleUploads, socketstoFlush: tmylist;
    lista_queued: tmylist;
    udppings: tmylist;
    pushes_out: tmylist;
    UDP_Socket: hsocket;
    UDP_RemoteSin: TVarSin;
    UDP_Buffer: array [0 .. 9999] of byte;
    UDP_len_recvd: integer;
    upload_bandwidth: cardinal;
    tempo, last_sec, last_accept, last_15_sec: cardinal;
    last_accept_chat: cardinal; // per prevenire superflodding chat
    lista_hashes_alternate_source: array [0 .. 255] of pointer;
    lista_accepted_chat: tmylist;
    // globale assegnata quando ho trovato file in library o in download parziale
    lista_user_granted: tmylist;
    socket: ttcpblocksocket; // main socket trattato
    meta_title: string; // per eventuale comunicazione in header per magnet uri
    meta_artist: string;
    meta_album: string;
    meta_category: string;
    meta_language: string;
    meta_date: string;
    meta_comments: string;
    header: string; // lowercase req
    header_backup: string; // req ma non lowercase per i vari base64 e nickname
    is_rehashing: boolean;
    xstats: string; // xstats inviate da nuovi uploader
    nickname: string; // nick including agent
    agent: string; // just agent
    partenza: int64; // want partial?
    fine: int64;
    nomefile: string;
    crcnomefile: word; // per velocizzare
    queue_firstinfirstout: boolean; // rispettiamo posizioni coda?
    filesize_reale: int64;
    ip_user, ip_server, ip_utente_interno: cardinal;
    port_user, port_server: word;
    his_progress: byte;
    his_numero_condivisi: integer; // impostato da apri general library view
    his_upcount: integer; // per stats
    his_downcount: integer;
    his_speed: cardinal;
    his_buildn: word;
    his_agent: string;
    wants_phash_indexs: boolean; // 2956+ send him phash indexs?
    phash_insertion_point: cardinal;
    is_encrypted: boolean;
    encryption_key: word;
    encryption_branch: byte;
    num_available: byte;
    MAX_SIZE_NO_QUEUE: cardinal; // minimo size che passa le code
    free_random_visual: integer; // per synch in get random #
    loc_max_ul_per_ip: byte;
    velocita_up_max: integer;
    speed_up_att: integer;
    socket_globale: ttcpblocksocket; // push e pget
    hash_sha1: string; // globale per invia tree hash
    crcsha1: word;
    velocita_max_ufrmmain: cardinal;
    m_graphObject: cardinal;
    FirstGraphSample: precord_graph_sample;
    LastGraphSample: precord_graph_sample;
    NumGraphStats: word;
    m_graphWidth: word;
    buffer_ricezione_handshake: array [0 .. 1024] of char;
    last_out_graph, last_minuto, last_ora: cardinal;
    bsentp, bsentpmega: int64;
    isSha1inLibrary: boolean;
    ce_in_download: boolean;
    upload_visual_per_synch: tupload; // per rimuovere upload da visual in synch
    risorsa_globale: trisorsa_download;
    // per aggiunta in synch su mp3webars.lista_temp
    procedure handle_plainTextRequests(sock: ttcpblocksocket);
    procedure XQueued_AssignUserValues(queued: precord_queued);
    procedure BindUdpSocket;
    function hasUDPPing(ip: cardinal): boolean;
    procedure receive_udp;
    procedure check_firewalled_status;
    procedure checkUDPPings;
    procedure SendUDPPing(udpping: precord_udpping);
    procedure handler_UDPTransferReq;
    procedure ParseUDPSrcInfo(SrcInfo: string; var wantXSize: boolean);
    function FindUDPUpload(sourceHandle: cardinal): tupload;
    procedure SendBackUDPError(ErCode: byte);
    function UDPFillData(upload: tupload; Len: cardinal;
      addHeaders: boolean): integer;
    function UDPFillXSizeReply: integer;
    procedure addUDPHeaders(var offset: integer);
    procedure GraphCreateFirstSamples;
    procedure GraphUpdate; // synchronize
    procedure GraphDeal(callsynch: boolean);
    procedure GraphAddSample(Value: integer);
    // procedure GraphCheckSync;
    procedure GraphIncrement(Elapsed: integer);
    procedure UploadsCheckTimeout; // ogni secondo
    function is_timeouted_upload(upload: tupload; tempo: cardinal): boolean;
    function is_user_granted: boolean; overload;
    function is_user_granted(ip: cardinal; port: word; ip_alt: cardinal)
      : boolean; overload;
    procedure add_user_granted; // in synch da prendi bandwidth
    function drop_slower_transfer: boolean;
    procedure check_hour;
    procedure check_second;
    procedure check_half_sec;
    procedure check_15_sec;
    procedure DHT_add_possible_bootstrap_client; // synch
    procedure flushSockets;
    function flushUpload(upload: tupload; loops: integer;
      amountPerCicle: integer): boolean;
    procedure free_alternates;
    procedure init_alternates;
    function find_alternate_holder(const hash_sha1: string)
      : precord_hash_holder_alternate;
    procedure add_alternate_source_holder(const hash_sha1: string;
      ip_user, ip_server: cardinal; port_user, port_server: word);
    // procedure accept_metti_ufrmmain_myport;
    procedure accept_listen;
    procedure accept_put_arrived_bittorrent;
    function accept_countfromip(const ip: string): integer;
    procedure accept_put_arrived_push; // in synch
    procedure add_chat_push_arrived;
    // cerchiamo randoms in socket_globale.testoricevuto
    procedure accept_crea_form_chat;
    procedure accept_accept; //
    procedure accept_receive_handshake;
    procedure expire_lista_accept_chat; // ogni minuto
    procedure Execute; override;
    procedure init_vars;
    procedure checkSha1inLibrary; // synch
    function CheckMaxULPerIp: boolean;
    procedure ParseAltSources(strin: string);
    function numero_queued_da_ip: integer;
    procedure xqueued_delete_queued_user(ip: cardinal; port: word; crc: word;
      nomefile: string);
    function xqueued_trova_queued(ip: cardinal; port: word; crc: word;
      nomefile: string): precord_queued;
    procedure ParseXStats;
    // function xqueued_in_listview(listview:tcomettree;queued:precord_queued):PCmtVNode;
    procedure handler_richiesta_encrypted(ForceGranted: boolean = false);
    procedure handler_push_arrived_encrypted(strin: string);
    procedure CheckPushedRequests;
    procedure CheckGetRequest(socket: ttcpblocksocket;
      var shouldDisconnect: boolean; var requestProcessed: boolean;
      isIdleUpload: boolean);
    procedure CheckIdleUploads;
    procedure free_upload_stuff(upload: tupload; should_continue: boolean);
    procedure prendi_bandwidth;
    // procedure xqueued_update_queue_log; // synchro
    function numero_up_da_ip(ip: cardinal; port: word;
      ip_alt: cardinal): integer;
    procedure XQueued_AssignPollTimeouts(queued: precord_queued);
    procedure SendHTTPACK(has_range: boolean);
    procedure SendHTTPError(ErrorCode: string);
    procedure SendHTTPBusy;
    function trova_queued_per_questa_req: precord_queued;
    procedure check_minuto;
    // procedure update_hint(treeview:tcomettree; node:PCmtVNode);
    procedure FlushHeaders(tempo: cardinal);
    procedure drop_upload_because_of_scanning; // 2953+
    procedure FlushFiles; overload;
    procedure FlushFiles(tempo: cardinal); overload;
    procedure FlushFiles(tempo: cardinal; dummy: boolean); overload;
    procedure update_transfer_treeview;
    // procedure update_listview_upload_eventuale;  // in synchronize
    // procedure add_new_upload_visual;//synch
    // procedure termina_upload_visual; //synch  upload_visual_per_synch
    // function trova_stesso_file( upload:tupload ):PCmtVNode;
    procedure metti_velocita_up; // synch  sempre per special caption
    procedure metti_nuova_velocita_up; // in synchronize
    procedure shutdown;
    procedure error_upload;
    procedure pushing_deal;
    procedure SendHTTPMetas;
    procedure pushing_sync;
    procedure xqueued_controlla_timeouts;
    procedure pushing_activate(push: Precord_push_to_go);
    // procedure update_statusbar_1;
    function upload_count: cardinal;
    function GetAltSources(evitaip: cardinal): string;
    function GetBinAltSources(evitaip: cardinal): string;
    function GetPartialSources(evitaip: cardinal): string;
    // partial sono aggiunti solo quando almeno uno ?stato completato! (buona affidabilit?sorgente)
  end;
implementation
uses
  helper_unicode, helper_crypt, helper_strings, helper_base64_32,
  helper_diskio, helper_sockets, helper_ipfunc, helper_urls, helper_sorting,
  helper_registry, vars_global, helper_datetime, secureHash,
  // ufrm_settings, ufrmmain,ufrmpvt,
  helper_ares_nodes, helper_http, const_udpTransfer, helper_private_chat,
  mysupernodes,
  const_timeouts, helper_ICH, helper_download_misc, bittorrentConst;
procedure tthread_upload.CheckIdleUploads;
var
  i, er: integer;
  shouldDisconnect, requestProcessed: boolean;
begin
  i := 0;
  while (i < IdleUploads.count) do
  begin
    socket := IdleUploads[i];
    if tempo - socket.tag > TIMEOUT_RECEIVE_HANDSHAKE then
    begin
      IdleUploads.delete(i);
      socket.free;
      continue;
    end;
    if not TCPSocket_CanRead(socket.socket, 0, er) then
    begin
      if ((er <> 0) and (er <> WSAEWOULDBLOCK)) then
      begin
        IdleUploads.delete(i);
        socket.free;
      end
      else
        inc(i);
      continue;
    end;
    CheckGetRequest(socket, shouldDisconnect, requestProcessed, true);
    if shouldDisconnect then
    begin
      IdleUploads.delete(i);
      socket.free;
    end
    else if requestProcessed then
      IdleUploads.delete(i)
    else
      inc(i);
  end;
end;
procedure tthread_upload.CheckPushedRequests;
var
  i, er: integer;
  shouldDisconnect, requestProcessed: boolean;
begin
  try
    i := 0;
    while (i < pushedRequests.count) do
    begin
      socket := pushedRequests[i]; // global
      if tempo - socket.tag > TIMEOUT_RECEIVE_HANDSHAKE then
      begin
        pushedRequests.delete(i);
        socket.free;
        continue;
      end;
      if not TCPSocket_CanRead(socket.socket, 0, er) then
      begin
        if ((er <> 0) and (er <> WSAEWOULDBLOCK)) then
        begin
          pushedRequests.delete(i);
          socket.free;
        end
        else
          inc(i);
        continue;
      end;
      CheckGetRequest(socket, shouldDisconnect, requestProcessed, false);
      if shouldDisconnect then
      begin
        pushedRequests.delete(i);
        socket.free;
      end
      else if requestProcessed then
        pushedRequests.delete(i)
      else
        inc(i);
    end;
  except
  end;
end;
procedure tthread_upload.CheckGetRequest(socket: ttcpblocksocket;
  var shouldDisconnect: boolean; var requestProcessed: boolean;
  isIdleUpload: boolean);
var
  previous_len, er, Len: integer;
  str: string;
  len_want: word;
  commandID, bytes_skipped: byte;
begin
  shouldDisconnect := false;
  requestProcessed := false;
  Len := TCPSocket_RecvBuffer(socket.socket, @buffer_ricezione_handshake,
    sizeof(buffer_ricezione_handshake), er);
  if er = WSAEWOULDBLOCK then
    exit;
  if er <> 0 then
  begin
    shouldDisconnect := true;
    exit;
  end;
  previous_len := length(socket.buffstr);
  setLength(socket.buffstr, previous_len + Len);
  move(buffer_ricezione_handshake, socket.buffstr[previous_len + 1], Len);
  socket.tag := tempo;
  if length(socket.buffstr) < 6 then
    exit;
  str := d3a(socket.buffstr, 23836);
  bytes_skipped := ord(str[3]);
  if bytes_skipped >= 17 then
  begin
    shouldDisconnect := true;
    exit;
  end;
  if length(socket.buffstr) < bytes_skipped + 5 then
    exit;
  len_want := chars_2_word(copy(str, 4 + bytes_skipped, 2));
  if length(socket.buffstr) < bytes_skipped + 5 + len_want then
    exit;
  if len_want < 5 then
  begin
    shouldDisconnect := true;
    exit;
  end;
  delete(str, 1, bytes_skipped + 5);
  str := d12(str, 16298);
  commandID := ord(str[1]);
  delete(str, 1, 1);
  case commandID of
    0, 1:
      begin // GET
        socket.buffstr := str;
        socket.tag := gettickcount;
        requestProcessed := true;
        handler_richiesta_encrypted(isIdleUpload);
        sleep(2);
      end
  else
    shouldDisconnect := true;
  end;
end;
procedure tthread_upload.handler_push_arrived_encrypted(strin: string);
var
  hash_sha1, randoms: string;
  command: byte;
  Len: word;
  cont: string;
begin
  try
    while (length(strin) >= 3) do
    begin
      Len := chars_2_word(copy(strin, 1, 2));
      command := ord(strin[3]);
      cont := copy(strin, 4, Len);
      delete(strin, 1, 3 + Len);
      if length(cont) <> Len then
        continue;
      case command of
        1:
          begin
            randoms := cont;
          end;
        2:
          begin
            hash_sha1 := copy(cont, 1, 20);
            if length(hash_sha1) <> 20 then
              break;
            socket_globale.buffstr := 'PUSH SHA1:' +
              bytestr_to_hexstr(hash_sha1) + randoms + chr(10) + chr(10);
            EnterCriticalSection(ServiceSection);
            try
              { synchronize } (accept_put_arrived_push);
            finally
              LeaveCriticalSection(ServiceSection);
            end;
            exit;
          end;
      end;
    end;
    socket_globale.free;
  except
  end;
end;
procedure tthread_upload.DHT_add_possible_bootstrap_client; // synch
begin
  if ip_user = 0 then
    exit;
  if port_user = 0 then
    exit;
  DHT_possibleBootstrapClientIP := ip_user;
  DHT_possibleBootstrapClientPort := port_user;
end;
procedure tthread_upload.handler_richiesta_encrypted(ForceGranted
  : boolean = false);
var
  Len: word;
  command: byte;
  cont, str_temp: string;
  want_size_magnet, granted: boolean;
  alt_sources: string;
  upload: tupload;
begin
  try
    ip_user := inet_addr(pchar(socket.ip)); // per ban
    if is_banned_ip(ip_user) then
    begin
      SendHTTPError(HTTPERROR403);
      exit;
    end;
    agent := '';
    his_agent := '';
    nickname := '';
    partenza := -1;
    fine := -1;
    port_server := 0;
    ip_server := 0;
    port_user := 0;
    xstats := '';
    hash_sha1 := '';
    is_encrypted := true;
    encryption_key := 0;
    encryption_branch := 0;
    want_size_magnet := false;
    wants_phash_indexs := false;
    his_buildn := 0;
    while (length(socket.buffstr) > 3) do
    begin
      Len := chars_2_word(copy(socket.buffstr, 1, 2));
      command := ord(socket.buffstr[3]);
      cont := copy(socket.buffstr, 4, Len);
      delete(socket.buffstr, 1, 3 + Len);
      if length(cont) <> Len then
        continue; // wrong sized field??
      case command of
        TAG_ARESHEADER_CRYPTBRANCH:
          begin // encryption method and key
            if Len >= 3 then
            begin
              encryption_branch := ord(cont[1]);
              if encryption_branch = 1 then
                encryption_key := chars_2_word(copy(cont, 2, 2))
              else
              begin // we can't handle
                SendHTTPError(HTTPERROR501);
                exit;
              end;
            end
            else
            begin // we can't handle
              SendHTTPError(HTTPERROR501);
              exit;
            end;
          end;
        TAG_ARESHEADER_WANTEDHASH:
          begin // wanted sha1
            hash_sha1 := copy(cont, 1, 20);
            crcsha1 := crcstring(hash_sha1); // global
          end;
        TAG_ARESHEADER_NICKNAME:
          nickname := cont;
        TAG_ARESHEADER_HOSTINFO1:
          begin // serverip  serverport  ip  port  ip_alt
            if ((ip_server = 0) and (port_server = 0) and (ip_user = 0)) then
            begin // old server host info may come later than lost info2 overwriting data to port_server=0 etc
              ip_server := chars_2_dword(copy(cont, 1, 4));
              port_server := chars_2_word(copy(cont, 5, 2));
              ip_user := chars_2_dword(copy(cont, 7, 4)); // per ban
              port_user := chars_2_word(copy(cont, 11, 2));
              ip_utente_interno := chars_2_dword(copy(cont, 13, 4));
              helper_ares_nodes.aresnodes_add_candidate(ip_server, port_server,
                ares_aval_nodes);
            end;
          end;
        TAG_ARESHEADER_XSIZE:
          want_size_magnet := true;
        // 6:begin  //stringa stats
        // xstats:=d2(cont,45876);
        // end;
        TAG_ARESHEADER_RANGE32:
          begin // range dword+dword
            partenza := chars_2_dword(copy(cont, 1, 4));
            fine := chars_2_dword(copy(cont, 5, 4));
          end;
        TAG_ARESHEADER_ALTSSRC:
          alt_sources := cont;
        TAG_ARESHEADER_AGENT:
          begin // agent
            his_agent := trim(cont);
            agent := get_first_word(trim(cont));
            str_temp := copy(cont, pos(' ', cont) + 1, length(cont)); // 2958+
            str_temp := trim(str_temp);
            delete(str_temp, 1, pos('.', str_temp)); // 1.8.1.2957 -> 8.1.2957
            delete(str_temp, 1, pos('.', str_temp)); // 8.1.2957 -> 1.2957
            delete(str_temp, 1, pos('.', str_temp)); // 1.2957 -> 2957
            his_buildn := strtointdef(str_temp, 0);
            if his_buildn >= DHT_SINCE_BUILD then
            begin
              EnterCriticalSection(ServiceSection);
              try
                { synchronize } (DHT_add_possible_bootstrap_client);
              finally
                LeaveCriticalSection(ServiceSection);
              end;
            end;
          end;
        TAG_ARESHEADER_XSTATS1:
          begin // 2948+
            cont := d67(d64(cont, 24384), 5593);
            delete(cont, 1, 1);
            // BYTE(random)    DWORD(random)    NULL    BYTE(random)    WH(DWORD(random)+21)    PAYLOAD
            if ((cont[5] = CHRNULL) and (chars_2_word(copy(cont, 7, 2))
              = word(wh(copy(cont, 1, 4)) + 21))) then
            begin
              delete(cont, 1, 8);
              if length(cont) > 18 then
              begin
                // if cont[18]<>chr(17) then
                xstats := d2(cont, 45876); // else xstats:=cont;
              end;
            end;
          end;
        TAG_ARESHEADER_XSTATS2:
          xstats := cont; // 01/01/2006
        TAG_ARESHEADER_RANGE64:
          begin // 2951+
            partenza := chars_2_Qword(copy(cont, 1, 8));
            fine := chars_2_Qword(copy(cont, 9, 8));
          end;
        TAG_ARESHEADER_ICHREQ:
          begin // 2956+
            if length(cont) >= 1 then
            begin
              if cont[1] = chr(1) then
                wants_phash_indexs := true; // send him phash
            end;
          end;
        TAG_ARESHEADER_HOSTINFO2:
          begin // new detail str 12/29/2005
            ip_user := chars_2_dword(copy(cont, 1, 4));
            port_user := chars_2_word(copy(cont, 5, 2));
            ip_utente_interno := chars_2_dword(copy(cont, 7, 4));
            if length(cont) > 10 then
            begin
              ip_server := chars_2_dword(copy(cont, 11, 4));
              port_server := chars_2_word(copy(cont, 15, 2));
              // add potential supernodes
              delete(cont, 1, 10);
              helper_ares_nodes.aresnodes_add_candidates
                (copy(cont, 1, length(cont)), ares_aval_nodes);
            end;
            // 0 to 4 other servers follow here
          end;
      end;
    end;
    nickname := strip_websites_str(nickname);
    if nickname = '' then
      nickname := ipdotstring_to_anonnick(socket.ip);
    if agent = '' then
      agent := STR_FOURQSTNMRK;
    nickname := nickname + '@' + agent;
    /// ////////////////////////c'?file in library?
    EnterCriticalSection(ServiceSection);
    try
      { synchronize } (checkSha1inLibrary);
    finally
      LeaveCriticalSection(ServiceSection);
    end;
    if isSha1inLibrary then
    begin
      crcnomefile := stringcrc(nomefile, true);
      if want_size_magnet then
      begin // send size of file to this dude(magnet URI)
        SendHTTPMetas;
        exit;
      end;
      if wants_phash_indexs then
        if filesize_reale > ICH_MIN_FILESIZE then
        begin
          upload := ICH_send_Phash(tempo, hash_sha1, socket,
            phash_insertion_point, encryption_key, filesize_reale);
          if upload <> nil then
            lista_upload.add(upload)
          else
            SendHTTPError(HTTPERROR500);
          exit;
        end;
      if length(alt_sources) >= 12 then
        ParseAltSources(alt_sources);
      ParseXStats;
      if ForceGranted then
        granted := true
      else
        granted := is_user_granted;
      if filesize_reale < MAX_SIZE_NO_QUEUE then
      begin
        SendHTTPACK(((partenza <> -1) or (fine <> -1)));
        exit;
      end;
      if not granted then
        if upload_count + cardinal(IdleUploads.count) >=
          cardinal(m_limite_upload) then
        begin
          SendHTTPBusy;
          exit;
        end;
      if not CheckMaxULPerIp then
      begin
        SendHTTPBusy;
        exit;
      end;
      SendHTTPACK(((partenza <> -1) or (fine <> -1)));
      exit;
    end;
    if is_rehashing then
      SendHTTPError(HTTPERROR510)
    else
      SendHTTPError(HTTPERROR404);
  except
    SendHTTPError(HTTPERROR500);
  end;
end;
function tthread_upload.CheckMaxULPerIp: boolean;
begin
  result := true;
  if loc_max_ul_per_ip = 0 then
    exit;
  if numero_up_da_ip(ip_user, port_user, ip_utente_interno) >= loc_max_ul_per_ip
  then
    result := false;
end;
procedure tthread_upload.ParseAltSources(strin: string);
var
  port_server_parse, port_user_parse: word;
  ip_user_parse, ip_server_parse: cardinal;
  ip_user_parses, ip_server_parses: string;
begin // format ip_server port_server ip_user port_user
  try
    while (length(strin) >= 12) do
    begin
      ip_server_parse := chars_2_dword(copy(strin, 1, 4));
      port_server_parse := chars_2_word(copy(strin, 5, 2));
      ip_user_parse := chars_2_dword(copy(strin, 7, 4));
      port_user_parse := chars_2_word(copy(strin, 11, 2));
      delete(strin, 1, 12);
      if isAntiP2PIP(ip_server_parse) then
        continue;
      if isAntiP2PIP(ip_user_parse) then
        continue;
      ip_user_parses := ipint_to_dotstring(ip_user_parse);
      if ip_user_parses = localip then
        continue;
      if ip_firewalled(ip_user_parses) then
        continue;
      ip_server_parses := ipint_to_dotstring(ip_server_parse);
      if ip_firewalled(ip_server_parses) then
        continue;
      if port_server_parse = 0 then
        continue;
      if port_user_parse = 0 then
        continue;
      add_alternate_source_holder(hash_sha1, ip_user_parse, ip_server_parse,
        port_user_parse, port_server_parse);
    end;
  except
  end;
end;
procedure tthread_upload.checkSha1inLibrary; // synch
var
  hi: integer;
  pfile: precord_file_library;
begin
  isSha1inLibrary := false;
  is_rehashing := false;
  try
    if vars_global.share <> nil then
    begin
      is_rehashing := true; // true
      exit;
    end;
  except
  end;
  if vars_global.my_shared_count = 0 then
    exit; // sta facendo scan 2953
  try
    for hi := 0 to vars_global.lista_shared.count - 1 do
    begin
      pfile := vars_global.lista_shared[hi];
      if not pfile^.shared then
        continue;
      if pfile^.crcsha1 <> crcsha1 then
        continue;
      if pfile^.hash_sha1 <> hash_sha1 then
        continue;
      isSha1inLibrary := true; // vittorioso! globale
      nomefile := pfile^.path; // globale!
      filesize_reale := pfile^.fsize;
      phash_insertion_point := pfile^.phash_index; // 2956+
      meta_title := pfile^.title;
      meta_artist := pfile^.artist;
      meta_album := pfile^.album;
      meta_category := pfile^.category;
      meta_language := pfile^.language;
      meta_date := pfile^.year;
      meta_comments := pfile^.comment;
      break;
    end;
  except
  end;
end;
function tthread_upload.is_user_granted(ip: cardinal; port: word;
  ip_alt: cardinal): boolean;
var
  us_granted: precord_user_granted;
  i: integer;
begin
  result := false;
  if lista_user_granted = nil then
    exit;
  if ip = 0 then
    exit
  else if port = 0 then
    exit;
  for i := 0 to lista_user_granted.count - 1 do
  begin
    us_granted := lista_user_granted[i];
    if us_granted^.port_user = port then
      if us_granted^.ip_user = ip then
        if us_granted^.ip_alt = ip_alt then
        begin
          result := true;
          exit;
        end;
  end;
end;
function tthread_upload.is_user_granted: boolean;
var
  us_granted: precord_user_granted;
  i: integer;
begin
  result := false;
  if lista_user_granted = nil then
    exit;
  if ip_user = 0 then
    exit
  else if port_user = 0 then
    exit;
  for i := 0 to lista_user_granted.count - 1 do
  begin
    us_granted := lista_user_granted[i];
    if us_granted^.port_user = port_user then
      if us_granted^.ip_user = ip_user then
        if us_granted^.ip_alt = ip_utente_interno then
        begin
          result := true;
          exit;
        end;
  end;
end;
function tthread_upload.drop_slower_transfer: boolean;
var
  i, ind: integer;
  up, slower: tupload;
  min_speed: integer;
  tm: cardinal;
begin
  result := false;
  min_speed := -1;
  slower := nil;
  tm := gettickcount;
  for i := 0 to lista_upload.count - 1 do
  begin
    up := lista_upload[i];
    if not up.should_display then
      continue;
    if tm - up.start_time < 10000 then
      continue;
    if is_user_granted(up.ip_user, up.port_user, up.ip_alt) then
      continue;
    {
      if (up.his_buildn xor vars_global.buildno)>10 then begin
      slower:=up;
      break;
      end;
    }
    if min_speed = -1 then
    begin
      min_speed := up.velocita;
      slower := up;
    end;
    if up.velocita < min_speed then
    begin
      min_speed := up.velocita;
      slower := up;
    end;
  end;
  if slower = nil then
    exit;
  ind := lista_upload.indexof(slower);
  if ind <> -1 then
  begin
    lista_upload.delete(ind);
    free_upload_stuff(slower, true);
    upload_visual_per_synch := slower;    slower.free;
  end
  else
    slower.socket.closesocket;
  result := true;
end;
function tthread_upload.numero_up_da_ip(ip: cardinal; port: word;
  ip_alt: cardinal): integer;
var
  i: integer;
  upload: tupload;
begin
  result := 0;
  try
    for i := 0 to lista_upload.count - 1 do
    begin
      upload := lista_upload[i];
      if not upload.should_display then
        continue;
      if upload.port_user = port then
        if upload.ip_user = ip then
          if upload.ip_alt = ip_alt then
            inc(result);
    end;
  except
  end;
end;
procedure tthread_upload.ParseXStats;
begin
  his_progress := 0;
  his_downcount := 40;
  his_upcount := -1;
  num_available := 1;
  his_numero_condivisi := -1;
  his_speed := 0;
  if length(xstats) < 18 then
    exit;
  if xstats[18] <> chr(17) then
    exit;
  try
    num_available := ord(xstats[6]);
    his_progress := ord(xstats[7]);
    his_speed := chars_2_dword(copy(xstats, 8, 4));
    if length(xstats) > 20 then
    begin
      his_numero_condivisi := chars_2_word(copy(xstats, 19, 2));
      // impostato da apri general library view
      his_upcount := ord(xstats[21]);
      if length(xstats) > 21 then
      begin
        his_downcount := ord(xstats[22]);
        // if length(xstats)>22 then his_pl:=ord(xstats[23]);
      end;
    end
    else
    begin
      his_numero_condivisi := -1;
      his_upcount := -1;
    end;
  except
  end;
end;
procedure tthread_upload.SendHTTPACK(has_range: boolean);
var
  stringa, str: string;
  i: cardinal; // integer;
  size: int64;
  upload: tupload;
  stream: thandlestream;
  skipped_len: byte;
begin
  try
    size := filesize_reale;
    if partenza < 0 then
      partenza := 0;
    if fine < 0 then
      fine := size - 1; // not set
    if ((partenza >= size) or (fine < partenza)) then
    begin // wrong request...stay away from me
      SendHTTPError(HTTPERROR416);
      exit;
    end;
    if fine + 1 > size then
      fine := size - 1; // correzione per bug in 2956+
    if (fine - partenza) + 1 > MAX_CHUNK_SIZE then
      fine := (partenza + MAX_CHUNK_SIZE) - 1; // mai troppo grossi sti chunk!
    stream := MyFileOpen(utf8strtowidestr(nomefile), ARES_READONLY_ACCESS);
    if stream = nil then
    begin
      SendHTTPError(HTTPERROR500);
      exit;
    end;
    if has_range then
      stringa := HTTP206
    else
      stringa := HTTP200;
    stringa := STR_HTTP1 + stringa + CRLF + STR_SERVER_ARES +
      vars_global.versioneares + CRLF + STR_MYNICK + CHRSPACE +
      vars_global.mynick + CRLF + STR_XB64MYDET + CHRSPACE +
      encodebase64(helper_ipfunc.serialize_myConDetails) + CRLF;
    stringa := stringa + GetAltSources(ip_user); // +
    // GetPartialSources(ip_user);
    if has_range then
    begin
      stringa := stringa + STR_CONTENT_RANGE + inttostr(partenza) + '-' +
        inttostr(fine) + '/' + inttostr(size) + CRLF + STR_CONTENT_LENGTH +
        inttostr((fine - partenza) + 1) + CRLF + CRLF;
    end
    else
    begin
      stringa := stringa + STR_CONTENT_LENGTH + inttostr((fine - partenza) + 1)
        + CRLF + CRLF;
      partenza := 0;
    end;
    upload := tupload.create(tempo);
    if is_encrypted then
    begin
      skipped_len := random(16) + 1;
      str := chr(random($FF)) + chr(random($FF)) + chr(skipped_len);
      for i := 1 to skipped_len do
        str := str + chr(random($FF));
      stringa := str + stringa;
      upload.is_encrypted := true;
      upload.encryption_key := encryption_key;
      for i := 1 to length(stringa) do
      begin
        stringa[i] := char(byte(stringa[i]) xor (upload.encryption_key shr 8));
        upload.encryption_key := (byte(stringa[i]) + upload.encryption_key) *
          52079 + 16826;
      end;
    end;
    upload.stream := stream;
    upload.his_progress := his_progress;
    upload.his_agent := his_agent;
    upload.his_upcount := his_upcount;
    if his_downcount = 0 then
      upload.his_downcount := 1
    else
      upload.his_downcount := his_downcount;
    upload.his_shared := his_numero_condivisi;
    upload.his_speedDL := his_speed;
    upload.num_available := num_available;
    upload.port_server := port_server;
    upload.ip_server := ip_server;
    upload.port_user := port_user;
    upload.ip_user := ip_user;
    upload.ip_alt := ip_utente_interno;
    upload.nickname := nickname;
    upload.crcnick := stringcrc(nickname, true);
    upload.socket := socket;
    socket.tag := upload.start_time;
    upload.filename := nomefile;
    upload.crcfilename := crcnomefile;
    upload.out_reply_header := stringa;
    upload.actual := partenza;
    upload.startpoint := partenza;
    upload.endpoint := fine;
    upload.size := (fine - partenza) + 1;
    upload.filesize_reale := filesize_reale;
    upload.bytesprima := partenza;
    upload.velocita := 0;
    upload.should_display := true;
    if upload.actual > 0 then
    begin
      helper_diskio.MyFileSeek(upload.stream, upload.actual,
        ord(soFromBeginning));
      if helper_diskio.MyFileSeek(upload.stream, 0, ord(soCurrent)) <> upload.actual
      then
      begin
        sleep(10);
        helper_diskio.MyFileSeek(upload.stream, upload.actual,
          ord(soFromBeginning));
      end;
    end;
    lista_upload.add(upload);
 
  except
    socket.free;
  end;
end;
procedure tthread_upload.SendHTTPError(ErrorCode: string);
var
  stringa, str: string;
  skipped_len: byte;
  i: integer;
begin
  try
    stringa := STR_HTTP1 + ErrorCode + CRLF + STR_SERVER_ARES +
      vars_global.versioneares + CRLF + CRLF;
    if is_encrypted then
    begin
      skipped_len := random(16) + 1;
      str := chr(random($FF)) + chr(random($FF)) + chr(skipped_len);
      for i := 1 to skipped_len do
        str := str + chr(random($FF));
      stringa := str + stringa;
      stringa := e54(stringa, encryption_key);
    end;
    socket.buffstr := stringa;
    socket.tag := tempo;
    socketstoFlush.add(socket);
  except
  end;
end;
procedure tthread_upload.SendHTTPMetas;
var
  stringa: string;
begin
  try
    stringa := STR_HTTP1 + HTTP200 + CRLF + STR_SERVER_ARES +
      vars_global.versioneares + CRLF + STR_MYNICK + chr(32) +
      vars_global.mynick + CRLF + STR_XB64MYDET + chr(32) +
      encodebase64(helper_ipfunc.serialize_myConDetails) + CRLF + 'X-Title: ' +
      urlencode(meta_title) + CRLF + 'X-Artist: ' + urlencode(meta_artist) +
      CRLF + 'X-Album: ' + urlencode(meta_album) + CRLF + 'X-Type: ' +
      urlencode(meta_category) + CRLF + 'X-Language: ' +
      urlencode(meta_language) + CRLF + 'X-Date: ' + urlencode(meta_date) + CRLF
      + 'X-Comments: ' + urlencode(meta_comments) + CRLF + 'X-Size: ' +
      inttostr(filesize_reale) + CRLF + CRLF;
    socket.buffstr := stringa;
    socket.tag := tempo;
    socketstoFlush.add(socket);
  except
  end;
end;
function tthread_upload.upload_count: cardinal;
var
  i: integer;
  upload: tupload;
begin
  result := 0;
  try
    for i := 0 to lista_upload.count - 1 do
    begin
      upload := lista_upload[i];
      if upload.should_display then
        inc(result);
    end;
  except
  end;
end;
{
  procedure tthread_upload.update_statusbar_1;  // in synchronize
  begin
  try
  vars_global.numero_upload:=upload_count;
  vars_global.numero_queued:=lista_queued.count;
  ares_FrmMain.update_status_transfer;
  except
  end;
  end;
}
function tthread_upload.numero_queued_da_ip: integer;
var
  i: integer;
  queued: precord_queued;
begin
  result := 0;
  for i := 0 to lista_queued.count - 1 do
  begin
    queued := lista_queued[i];
    if queued^.port = port_user then
      if queued^.ip = ip_user then
        if queued^.ip_alt = ip_utente_interno then
          inc(result);
  end;
end;
function tthread_upload.trova_queued_per_questa_req: precord_queued;
var
  hiq: integer;
  queued: precord_queued;
  pollmin_prec: cardinal;
begin
  result := nil;
  try
    // for hiq:=0 to lista_queued.count-1 do begin
    // queued:=lista_queued[hiq];
    // if queued^.ip<>ip_user then continue else
    // if queued^.port<>port_user then continue else
    // if queued^.crcnomefile<>crcnomefile then continue else
    // if queued^.nomefile<>nomefile then continue;
    // queued^.his_upcount:=his_upcount; //ora mettiamo in riga secondo il numero degli up, chi ha pi?up passa prima
    // break;
    // end;    // if lista_queued.count>1 then begin       2967 monday 27-6-2005
    // lista_queued.sort(ordina_queued_per_num_uploads);
    // for i:=0 to lista_queued.count-1 do begin //riassegniamo posizioni
    // queued2:=lista_queued[i];
    // queued2^.posizione:=i+1;
    // end;
    // end;
    for hiq := 0 to lista_queued.count - 1 do
    begin
      queued := lista_queued[hiq];
      if queued^.ip <> ip_user then
        continue
      else if queued^.port <> port_user then
        continue
      else if queued^.crcnomefile <> crcnomefile then
        continue
      else if queued^.nomefile <> nomefile then
        continue;
      queued^.posizione := hiq + 1;
      queued^.user := nickname;
      queued^.server_ip := ip_server;
      queued^.server_port := port_server;
      queued^.ip_alt := ip_utente_interno;
      pollmin_prec := queued^.polltime;
      inc(queued^.total_tries);
      queued^.retry_interval := ((gettickcount - pollmin_prec) div 1000);
      queued^.polltime := gettickcount;
      queued^.size := filesize_reale;
      queued^.his_progress := his_progress;
      queued^.num_available := num_available;
      queued^.his_shared := his_numero_condivisi;
      queued^.his_downcount := his_downcount;
      queued^.his_speedDL := his_speed;
      queued^.his_agent := his_agent;
      if queue_firstinfirstout then
      begin
        if queued^.posizione < 3 then
        begin
          queued^.pollmin := 30;
          queued^.pollmax := 90;
        end
        else if queued^.posizione < 10 then
        begin
          queued^.pollmin := 60;
          queued^.pollmax := 120;
        end
        else if queued^.posizione < 20 then
        begin
          queued^.pollmin := 120;
          queued^.pollmax := 180;
        end
        else
        begin
          queued^.pollmin := 240;
          queued^.pollmax := 300;
        end;
      end
      else
      begin
        queued^.pollmin := 60;
        queued^.pollmax := 120;
      end;
      result := queued;
      break;
    end; // fine for?
  except
  end;
end;
procedure tthread_upload.SendHTTPBusy;
var
  stringa, str: string;
  queued: precord_queued;
  num, i: integer;
  canAdd: boolean;
  skipped_len: byte;
begin
  try
    stringa := STR_HTTP1 + HTTPERROR503 + CRLF + STR_SERVER_ARES +
      vars_global.versioneares + CRLF + STR_MYNICK + CHRSPACE +
      vars_global.mynick + CRLF + STR_XB64MYDET + CHRSPACE +
      encodebase64(helper_ipfunc.serialize_myConDetails) + CRLF;
    queued := trova_queued_per_questa_req;
    if queued <> nil then
      stringa := stringa + STR_XQUEUED_HEADER + inttostr(queued^.posizione) +
        ',' + STR_LENGTH_HEADER + inttostr(lista_queued.count) + ',' + STR_LIMIT
        + inttostr(m_limite_upload) + ',' + STR_POLLMIN +
        inttostr(queued.pollmin) + ',' + STR_POLLMAX +
        inttostr(queued.pollmax) + CRLF
    else if lista_queued.count >= NUM_MAX_QUEUED then // not found and list full
      stringa := stringa + STR_XQUEUED_HEADER + '102,' + STR_LENGTH_HEADER +
        inttostr(lista_queued.count) + ',' + STR_LIMIT +
        inttostr(m_limite_upload) + ',' + STR_POLLMIN + '240,' + STR_POLLMAX +
        '360' + CRLF
    else
    begin // not found, and place in line available
      if loc_max_ul_per_ip <> 0 then
      begin
        num := numero_up_da_ip(ip_user, port_user, ip_utente_interno) +
          numero_queued_da_ip;
        canAdd := (num < loc_max_ul_per_ip);
        // is he within our max UL per IP settings?
        if not canAdd then
          stringa := stringa + STR_XQUEUED_HEADER + '103,' + STR_LENGTH_HEADER +
            inttostr(lista_queued.count) + ',' + STR_LIMIT +
            inttostr(m_limite_upload) + ',' + STR_POLLMIN + '125,' + STR_POLLMAX
            + '245' + CRLF;
      end
      else
        canAdd := true;
      if canAdd then
      begin
        queued := AllocMem(sizeof(record_queued));
        XQueued_AssignUserValues(queued);
        XQueued_AssignPollTimeouts(queued);
        lista_queued.add(queued);
        stringa := stringa + STR_XQUEUED_HEADER + inttostr(queued^.posizione) +
          ',' + STR_LENGTH_HEADER + inttostr(lista_queued.count) + ',' +
          STR_LIMIT + inttostr(m_limite_upload) + ',' + STR_POLLMIN +
          inttostr(queued.pollmin) + ',' + STR_POLLMAX +
          inttostr(queued.pollmax) + CRLF;
        // synchronize(update_statusbar_1);
      end;
end;
procedure TfrmDeviceManage.prip_GenerateIds;
var
  li_DevCode: Integer;
  ls_DevCode: string;
begin
  with BaseInfo do
    if not prif_CheckBlank(BaseInfo, [FieldByName('dev_code_id'),
      FieldByName('borough_id')]) then Exit;  ls_DevCode := Copy(DeviceCode.FieldByName('code').AsString, 1, 4);  with BaseInfo do
procedure TfrmDeviceManage.BaseInfoBeforeInsert(DataSet: TDataSet);
begin
  Fs_PrevRegId := '';
  Fs_PrevCustomId := '';
end;procedure TfrmDeviceManage.BaseInfoBeforeEdit(DataSet: TDataSet);
begin
  with DataSet do
  begin
    Fs_PrevDevCodeId := VarToStr(FieldValues['dev_code_id']);
    Fs_PrevDevCode := prif_GetDevCode(Fs_PrevDevCodeId);
    Fs_PrevRegId := VarToStr(FieldValues['reg_id']);
    Fs_PrevCustomId := VarToStr(FieldValues['custom_id']);
  end;
end;function TfrmDeviceManage.prif_GenerateRegId: string;
var
  ls_DevCodeId, ls_BoroughId, ls_RegDate, ls_TempId, ls_RegId: string;
begin
  with BaseInfo do
  begin
    ls_DevCodeId := Copy(DeviceCode.FieldByName('code').AsString, 1, 4);
    ls_BoroughId := Borough.FieldByName('code').AsString;
    ls_RegDate := VarToStr(FieldValues['reg_date']);
    if ls_RegDate <> '' then
    begin
      ls_RegDate := StringReplace(ls_RegDate, '-', '', [rfReplaceAll,
        rfIgnoreCase]);
      ls_RegDate := Copy(ls_RegDate, 1, 6);
    end else ls_RegDate := '';
    ls_TempId := ls_DevCodeId + '______' + ls_RegDate;
    ls_RegId := ls_DevCodeId + ls_BoroughId + ls_RegDate;
  end;
  
  with Temp do
  begin
    if Active then Close;
    if ls_RegDate <> '' then
      SQL.Text := Format('SELECT MAX(SUBSTRING(reg_id, 17, 4)) AS reg_id ' +
        'FROM device.equipment_info WHERE reg_id LIKE ''%s%%, [ls_TempId])
    else
      SQL.Text := Format('SELECT MAX(SUBSTRING(reg_id, 14, 4)) AS reg_id ' +
        'FROM device.equipment_info WHERE reg_id LIKE ''%s%%, [ls_TempId]);
    Open;
    if VarToStr(FieldValues['reg_id']) = '' then
      Result := ls_RegId + Format('%.4d', [1])
    else Result := ls_RegId + Format('%.4d',
      [StrToInt(RightStr(FieldByName('reg_id').AsString, 4)) + 1]);
  end;
end;procedure TfrmDeviceManage.bbtnGenerateIdClick(Sender: TObject);
begin
  prip_GenerateIds;
end;procedure TfrmDeviceManage.ListBeforeScroll(DataSet: TDataSet);
begin
  if not prif_CheckSaved then Abort;
end;function TfrmDeviceManage.prif_GenerateCustomId: string;
var
  li_DevCode: Integer;
  ls_SQL, ls_CustomIdHead: string;
begin
  li_DevCode := StrToInt(Copy(DeviceCode.FieldByName('code').AsString,
    1, 1));
  case li_DevCode of
    1:
      begin
        ls_CustomIdHead := 'G';
        ls_SQL := 'SELECT MAX(custom_id) AS custom_id FROM device.device_info ' +
          'WHERE custom_id LIKE ''G%'' AND dev_code_id LIKE ''1%;
      end;
    2:
      begin
        ls_CustomIdHead := 'R';
        ls_SQL := 'SELECT MAX(custom_id) AS custom_id FROM device.device_info ' +
          'WHERE custom_id LIKE ''R%'' AND dev_code_id LIKE ''2%;
      end;
    3..9:
      begin
        Result := '';
        Exit;
      end;
  end;
  
  with Temp do
  begin
    if Active then Close;
    SQL.Text := ls_SQL;
    Open;
    if VarToStr(FieldValues['custom_id']) = '' then
      Result := ls_CustomIdHead + Format('%.5d', [1])
    else Result := ls_CustomIdHead + Format('%.5d',
      [StrToInt(Copy(FieldByName('custom_id').AsString, 2, 5)) + 1]);
  end;
  function tthread_upload.xqueued_in_listview(listview:tcomettree; queued:precord_queued):pCmtVnode;
  var
  node:pCmtVnode;
  i:integer;
  data:precord_queued;
  begin
  result:=nil;
  try
  nodE:=nil;
  i:=0;
  repeat
  if i=0 then node:=listview.getfirst
  else node:=listview.getnext(node);
  if node=nil then break;
  inc(i);
  data:=listview.getdata(node);
  if data^.ip=queued^.ip then
  if data^.port=queued^.port then
  if data^.crcnomefile=queued^.crcnomefile then
  if data^.nomefile=queued^.nomefile then begin
  result:=node;
  exit;
  end;
  until (not true);
  except
  end;
  end;
}
function tthread_upload.xqueued_trova_queued(ip: cardinal; port: word;
  crc: word; nomefile: string): precord_queued;
var
  i: integer;
  queued: precord_queued;
begin
  result := nil;
  try
    for i := 0 to lista_queued.count - 1 do
    begin
      queued := lista_queued[i];
      if queued^.ip = ip then
        if queued^.port = port then
          if queued^.crcnomefile = crc then
            if queued^.nomefile = nomefile then
            begin
              result := queued;
              exit;
            end;
    end;
  except
  end;
end;
end;procedure TfrmDeviceManage.prip_RefreshDeviceInfo;
begin
  //TODO:
  with List do
  begin
    if Active then Close;
    SQL.Text := 'device.usp_getdevicedata';
    Open;
  end;  
end;procedure TfrmDeviceManage.navInfoBeforeAction(Sender: TObject;
  Button: TNavigateBtn);
begin
  if (Button = nbRefresh) and (Fi_ActMode = AM_DMBROWSEDEVICE) then
  begin
    Gp_ProgressHint('，...');
    try
      prip_RefreshDeviceInfo;
    finally
      Gp_ProgressHint;
    end;
    Abort;
  end;
end;procedure TfrmDeviceManage.bbtnPrintClick(Sender: TObject);
begin
  try
    List.DisableControls;
    BaseInfo.DisableControls;
    with PrintGrd do
    begin
      DBGridEh := grdList;
      Preview;
    end;
  finally
    List.EnableControls;
    BaseInfo.EnableControls;
  end;
end;procedure TfrmDeviceManage.prip_Adjust;
var
  li_i, li_Bottom, li_MaxBottom, li_Height: Integer;
begin
  li_MaxBottom := 0;
  with scrbBaseInfo do
    for li_i := 0 to ControlCount - 1 do
    begin
      li_Bottom := Controls[li_i].Top + Controls[li_i].Height;
      if li_Bottom > li_MaxBottom then li_MaxBottom := li_Bottom;
    end;
  Inc(li_MaxBottom, 5);
  li_Height := scrbBaseInfo.Height;
  if li_Height > li_MaxBottom then
  begin
    scrbBaseInfo.Align := alNone;
    scrbBaseInfo.Height := li_Height - li_MaxBottom;
    spList.Align := alTop;
    grdList.Align := alTop;
    grdList.Height := grdList.Height + (li_Height - li_MaxBottom);
    grdList.Align := alBottom;
    spList.Align := alBottom;
    scrbBaseInfo.Align := alClient;
  end;
end;procedure TfrmDeviceManage.prip_IniInterface;
begin
  case Fi_ActMode of
    AM_DMADDDEVICE, AM_DMEDITDEVICE:
      begin
        grdList.Visible := False;
        spList.Visible := False;
        rcpList.Visible := False;
        bbtnListFind.Visible := False;
        bbtnListFilter.Visible := False;
        bbtnListColumn.Visible := False;
        bbtnListInsert.Visible := False;
        bbtnListDelete.Visible := False;
        bbtnExport.Visible := False;
        bbtnPrint.Visible := False;
        bbtnReplaceDevice.Visible := False;
      end;
  end;
end;
  begin
    li_DevCode := StrToInt(Copy(DeviceCode.FieldByName('code').AsString, 1, 1));
    if State = dsInsert then
    begin
      FieldByName('reg_id').AsString := prif_GenerateRegId;
      if GENDEVCIDBYARITHMETIC then
        case li_DevCode of
          1: FieldByName('custom_id').AsString := prif_GenerateCustomId;
          2: FieldByName('custom_id').AsString := prif_GenerateCustomId;
          3..9: begin end;
        end;
    end else begin
      if ((Pos('', FieldByName('reg_id').AsString) <> 0) and
        (VarToStr(FieldByName('reg_date').AsString) <> '')) or
        (ls_DevCode <> Copy(FieldByName('reg_id').AsString, 1, 4)) then
      begin
        Edit;
        FieldByName('reg_id').AsString := prif_GenerateRegId;
      end;
      if VarToStr(FieldValues['custom_id']) = '' then
      begin
        Edit;
        if GENDEVCIDBYARITHMETIC then
          case li_DevCode of
            1: FieldByName('custom_id').AsString := prif_GenerateCustomId;
            2: FieldByName('custom_id').AsString := prif_GenerateCustomId;
            3..9: begin end;
          end;
      end;
    end;
  end;
end;procedure TfrmDeviceManage.prip_CompanyDialog(const Ai_Category: Integer;
  Ac_LookupComboBox: TDBLookupComboBoxEh; Ac_Requestor: TfrmOrganMng);
begin
  with BaseInfod do if (not AutoEdit) and (State = dsBrowse) then Exit;  with Ac_LookupComboBox do
    try
      prip_SelectCompany(Ai_Category, DataField, Ac_Requestor);
      ListSource := nil;
      ListSource := mComInfod;
    finally
      if Ac_Requestor <> nil then Ac_Requestor.Free;
    end;
end;procedure TfrmDeviceManage.prip_DeleteDevice;
var
  ls_Id, ls_DevCodeId: string;
begin
  with BaseInfo do
  begin
    if (not Active) or IsEmpty then Exit;
    ls_Id := FieldByName('sysid').AsString;
    ls_DevCodeId := Copy(DeviceCode.FieldByName('code').AsString, 1, 1);
  end;  if Application.MessageBox(',
    MB_OKCANCEL + MB_DEFBUTTON2 + MB_ICONQUESTION) = IDCANCEL then Exit;  Gp_ProgressHint(' ，...');
  try
    dmData.adocon.Execute(Format('device.usp_deletedeviceinfo ''%s'', ''%s,
      [ls_Id, ls_DevCodeId]));
  finally
    Gp_ProgressHint;
  end;  Gp_ProgressHint('，...');
  try
    prip_RefreshDeviceInfo;
  finally
    Gp_ProgressHint;
  end;
end;procedure TfrmDeviceManage.bbtnListDeleteClick(Sender: TObject);
begin
  prip_DeleteDevice;
end;procedure TfrmDeviceManage.bbtnReplaceDeviceClick(Sender: TObject);
begin
  prip_ReplaceDevice;
end;procedure TfrmDeviceManage.prip_ReplaceDevice;
begin
  frmDevReplaceDlg := TfrmDevReplaceDlg.Create(Self);
  frmDevReplaceDlg.pubp_Ini(Self);
end;procedure TfrmDeviceManage.prip_TargetForReplace;
var
  lc_DataSet: TdxMemData;
begin
  with BaseInfo do
  begin
    if not Active then Exit;
    if State <> dsBrowse then Exit;
  end;
  
  if Assigned(frmDevReplaceDlg) then
  begin
    case frmDevReplaceDlg.rdgSelected.ItemIndex of
      0: lc_DataSet := frmDevReplaceDlg.memSrc;
      1: lc_DataSet := frmDevReplaceDlg.memDest;
      else lc_DataSet := nil;
    end;
    with lc_DataSet do
    begin
      if RecordCount = 1 then
      begin
        Close;
        Open;
      end;
      Append;

      FieldValues['id'] := BaseInfo.FieldValues['sysid'];
      FieldValues['reg_id'] := BaseInfo.FieldValues['reg_id'];
      FieldValues['custom_id'] := BaseInfo.FieldValues['custom_id'];
      FieldValues['dev_code_id'] := DeviceCode.FieldValues['code'];
      FieldValues['dev_code_name'] := List.FieldValues['dev_code_name'];
      FieldValues['user_name'] := List.FieldValues['user_name'];
      if List.FindField('dev_type') <> nil then
        FieldValues['dev_type'] := List.FieldValues['dev_type'];
      if List.FindField('manu_no') <> nil then
        FieldValues['manu_no'] := List.FieldValues['manu_no'];
      Post;
    end;
  end;
end;procedure TfrmDeviceManage.grdListDblClick(Sender: TObject);
begin
  prip_TargetForReplace; 
end;procedure TfrmDeviceManage.CMRefreshDeviceInfo(var Msg: TMessage);
begin
  Gp_ProgressHint('，...');
  try
    prip_RefreshDeviceInfo;
  finally
    Gp_ProgressHint;
  end;
end;
user:=queued^.user;
  nomefile:=queued^.nomefile;
  crcnomefile:=queued^.crcnomefile;
  size:=queued^.size;
  ip:=queued^.ip;
  ip_alt:=queued^.ip_alt;
  port:=queued^.port;
  server_ip:=queued^.server_ip;
  server_port:=queued^.server_port;
    GroupBox1: TGroupBox;
    grdList: TDBGridEh;
    TabSheet3: TTabSheet;
    TabSheet4: TTabSheet;
    TabSheet5: TTabSheet;
    TabSheet6: TTabSheet;
    TabSheet7: TTabSheet;
    TabSheet8: TTabSheet;
    TabSheet10: TTabSheet;
    TabSheet11: TTabSheet;
    TabSheet12: TTabSheet;
    TabSheet13: TTabSheet;
    TabSheet14: TTabSheet;
    Panel6: TPanel;
    grdDeathDetail: TDBGridEh;
    Panel9: TPanel;
    grdInquiryDetail: TDBGridEh;
    Panel12: TPanel;
    grdLogDetail: TDBGridEh;
    CSBarMDIChild1: TCSBarMDIChild;
    ScrChild: TCSScrCtrlChild;
    Panel15: TPanel;
    Panel16: TPanel;
    Panel17: TPanel;
    Panel18: TPanel;
    Panel21: TPanel;
    Panel26: TPanel;
    TabSheet9: TTabSheet;
    Panel30: TPanel;
    Panel31: TPanel;
    Label50: TLabel;
    Label49: TLabel;
    deInquiryDate: TCSdxDBDateEdit;
    Panel32: TPanel;
    Panel33: TPanel;
    Panel34: TPanel;
    Label52: TLabel;
    Label53: TLabel;
    Panel35: TPanel;
    Panel36: TPanel;
    Panel37: TPanel;
    Label55: TLabel;
    Label56: TLabel;
    deInquiryDeptDate: TCSdxDBDateEdit;
    Panel38: TPanel;
    Temp: TCSADOQuery;
    bbtnSave: TBitBtn;
    bbtnCancel: TBitBtn;
    bbtnConfirm: TBitBtn;
    bbtnPrint: TBitBtn;
    Panel3: TPanel;
    bbtnListFind: TBitBtn;
    bbtnListFilter: TBitBtn;
    bbtnListColumn: TBitBtn;
    Panel4: TPanel;
    bbtnInsert: TBitBtn;
    bbtnDelete: TBitBtn;
    navList: TCSDBNavigator;
    Panel7: TPanel;
    Panel8: TPanel;
    bbtnAddDeathDetail: TBitBtn;
    bbtnDeleteDeathDetail: TBitBtn;
    navDeathDetail: TCSDBNavigator;
    mAcctResult: TdxDBMemo;
    mInquiryDifferIdea: TdxDBMemo;
    mInquiryDeptIdea: TdxDBMemo;
    mAcctRemark: TdxDBMemo;
    Panel10: TPanel;
    Panel11: TPanel;
    bbtnAddInquiryDetail: TBitBtn;
    bbtnDeleteInquiryDetail: TBitBtn;
    navInquiryDetail: TCSDBNavigator;
    Panel13: TPanel;
    Panel14: TPanel;
    bbtnAddLogDetail: TBitBtn;
    bbtnDeleteLogDetail: TBitBtn;
    navLogDetail: TCSDBNavigator;
    mAcctCourse: TdxDBMemo;
    mDestroyCircs: TdxDBMemo;
    General: TCSADOQuery;
    Generald: TDataSource;
    DeathDetaild: TDataSource;
    DeathDetail: TCSADOQuery;
    InquiryDetaild: TDataSource;
    InquiryDetail: TCSADOQuery;
    LogDetail: TCSADOQuery;
    LogDetaild: TDataSource;
    Province: TCSADOQuery;
    provinced: TDataSource;
    City: TCSADOQuery;
    cityd: TDataSource;
    Borough: TCSADOQuery;
    boroughd: TDataSource;
    DevPurpose: TCSADOQuery;
    DevPurposed: TDataSource;
    ScrollBox1: TScrollBox;
    GroupBox3: TGroupBox;
    Label9: TLabel;
    Label10: TLabel;
    Label24: TLabel;
    Label41: TLabel;
    Label1: TLabel;
    Label11: TLabel;
    Label25: TLabel;
    Label12: TLabel;
    Label2: TLabel;
    Label38: TLabel;
    eAcctCom: TDBEditEh;
    eAcctRegNo: TDBEditEh;
    eContact: TDBEditEh;
    eChiefDept: TDBEditEh;
    eTel: TDBEditEh;
    eZip: TDBEditEh;
    eFax: TDBEditEh;
    eEmail: TDBEditEh;
    lcmbOrgProperty: TdxDBPickEdit;
    eOrgAdress: TDBEditEh;
    GroupBox2: TGroupBox;
    Label18: TLabel;
    Label16: TLabel;
    Label17: TLabel;
    Label19: TLabel;
    Label39: TLabel;
    Label43: TLabel;
    eAcctAddress: TDBEditEh;
    lcmbProvince: TDBLookupComboboxEh;
    lcmbCity: TDBLookupComboboxEh;
    lcmbBorough: TDBLookupComboboxEh;
    eTown: TDBEditEh;
    CSdxDBDateEdit1: TCSdxDBDateEdit;
    GroupBox4: TGroupBox;
    Label6: TLabel;
    labDevName: TLabel;
    Label13: TLabel;
    Label4: TLabel;
    labUseCertId: TLabel;
    labDevInnerId: TLabel;
    Label8: TLabel;
    Label40: TLabel;
    Label42: TLabel;
    Label20: TLabel;
    Label27: TLabel;
    Label21: TLabel;
    Label29: TLabel;
    Label14: TLabel;
    Label15: TLabel;
    eDevName: TDBEditEh;
    eDevType: TDBEditEh;
    eDevRegNo: TDBEditEh;
    eDevCertNo: TDBEditEh;
    eDevInnerNo: TDBEditEh;
    lcmbDevCategory: TDBLookupComboboxEh;
    lcmbDevPurpose: TDBLookupComboboxEh;
    lcmbDevKind: TDBLookupComboboxEh;
    lcmbDevSort: TDBLookupComboboxEh;
    deUseDate: TCSdxDBDateEdit;
    deVerifyDate: TCSdxDBDateEdit;
    eManuCom: TDBEditEh;
    eDesignCom: TDBEditEh;
    eVerifyCom: TDBEditEh;
    eInstCom: TDBEditEh;
    GroupBox5: TGroupBox;
    Label7: TLabel;
    Label3: TLabel;
    Label23: TLabel;
    Label26: TLabel;
    Label28: TLabel;
    Label30: TLabel;
    Label31: TLabel;
    Label32: TLabel;
    Label33: TLabel;
    Label34: TLabel;
    Label35: TLabel;
    Label22: TLabel;
    deAuthDate: TCSdxDBDateEdit;
    stringa := stringa + GetAltSources(ip_user) +
    // GetPartialSources(ip_user)+
      CRLF;
    if is_encrypted then
    begin
      skipped_len := random(16) + 1;
      str := chr(random($FF)) + chr(random($FF)) + chr(skipped_len);
      for i := 1 to skipped_len do
        str := str + chr(random($FF));
      stringa := str + stringa;
      stringa := e54(stringa, encryption_key);
    end;
    socket.buffstr := stringa;
    socket.tag := tempo;
    socketstoFlush.add(socket);
  except
  end;
end;
  begin
    add_user_granted;
    vars_global.ip_user_granted := 0;
    vars_global.port_user_granted := 0;
    vars_global.ip_alt_granted := 0;
  end;
  if vars_global.my_shared_count = 0 then
  begin
    drop_upload_because_of_scanning;
    exit; // sta facendo scan
  end;
  // GraphCheckSync;
end;
procedure tthread_upload.add_user_granted; 
var
  us_granted: precord_user_granted;
  i: integer;
begin
  if lista_user_granted <> nil then
  begin
    for i := 0 to lista_user_granted.count - 1 do
    begin
      us_granted := lista_user_granted[i];
      if us_granted^.port_user = vars_global.port_user_granted then
        if us_granted^.ip_user = vars_global.ip_user_granted then
          if us_granted^.ip_alt = vars_global.ip_alt_granted then
            exit;
    end;
  end;
  us_granted := AllocMem(sizeof(record_user_granted));
  us_granted^.ip_user := vars_global.ip_user_granted;
  us_granted^.port_user := vars_global.port_user_granted;
  us_granted^.ip_alt := vars_global.ip_alt_granted;
  if lista_user_granted = nil then
    lista_user_granted := tmylist.create;
  lista_user_granted.add(us_granted);
end;
{
  procedure tthread_upload.xqueued_update_queue_log; // synchro
  var
  i:integer;
  node:pCmtVnode;
  queued,data:precord_queued;
  begin
  if ares_frmmain.tabs_pageview.activepage<>IDTAB_TRANSFER then exit;
  if not ares_FrmMain.treeview_queue.visible then exit; //queue invisibile
  try
  node:=nil;
  i:=0;
  repeat
  if i=0 then node:=ares_FrmMain.treeview_queue.getfirst
  else node:=ares_FrmMain.treeview_queue.GetNext(node);
  if node=nil then break;
  inc(i);

  data:=ares_FrmMain.treeview_queue.getdata(node);
  if data^.disconnect then begin  //perform ban
  xqueued_delete_queued_user(data^.ip,data^.port,data^.crcnomefile,data^.nomefile);
  ares_FrmMain.treeview_queue.deletenode(node);
  i:=0;
  continue;
  end else
  if data^.banned then begin
  add_ban(data^.ip);
  xqueued_delete_queued_user(data^.ip,data^.port,data^.crcnomefile,data^.nomefile);
  ares_FrmMain.treeview_queue.deletenode(node);
  i:=0;
  continue;
  end;
  //posiziona in lista e assegna posizione
  queued:=xqueued_trova_queued(data^.ip,data^.port,data^.crcnomefile,data^.nomefile);
  if queued=nil then begin
  ares_FrmMain.treeview_queue.deletenode(node);
  i:=0;
  continue;
  end;
  until (not true);  if lista_queued.count>1 then lista_queued.sort(ordina_xqueued);  // ordina secondo ordine che gli diamo noi
 
  for i:=0 to lista_queued.count-1 do begin
  queued:=lista_queued[i];
  node:=xqueued_in_listview(ares_FrmMain.treeview_queue,queued);
  if node=nil then begin
  node:=ares_FrmMain.treeview_queue.addchild(nil);
  data:=ares_FrmMain.treeview_queue.getdata(node);
  with data^ do begin
  disconnect:=false;
  banned:=false;
  user:=queued^.user;
  nomefile:=queued^.nomefile;
  crcnomefile:=queued^.crcnomefile;
  size:=queued^.size;
  ip:=queued^.ip;
  ip_alt:=queued^.ip_alt;
  port:=queued^.port;
  server_ip:=queued^.server_ip;
  server_port:=queued^.server_port;
  importance:=queued^.importance;
  his_progress:=queued^.his_progress;
  num_available:=queued^.num_available;
  his_shared:=queued^.his_shared;
  his_speedDL:=queued^.his_speedDL;
  his_upcount:=queued^.his_upcount;
  his_downcount:=queued^.his_downcount;
  his_agent:=queued^.his_agent;
  polltime:=queued^.polltime;
  retry_interval:=queued^.retry_interval;
  total_tries:=queued^.total_tries;
  queue_start:=queued^.queue_start;
  pollmax:=queued^.pollmax;
  posizione:=queued^.posizione;
  end;
  update_hint(ares_FrmMain.treeview_queue,node);
  end else begin
  data:=ares_FrmMain.treeview_queue.getdata(node);
  with data^ do begin
  importance:=queued^.importance;
  his_progress:=queued^.his_progress;
  num_available:=queued^.num_available;
  his_shared:=queued^.his_shared;
  his_upcount:=queued^.his_upcount;
  his_downcount:=queued^.his_downcount;
  his_speedDL:=queued^.his_speedDL;
  polltime:=queued^.polltime;
  server_ip:=queued^.server_ip;
  server_port:=queued^.server_port;
  pollmax:=queued^.pollmax;
  retry_interval:=queued^.retry_interval;
  total_tries:=queued^.total_tries;
  posizione:=queued^.posizione;
  end;
  ares_FrmMain.treeview_queue.invalidatenode(node);
  update_hint(ares_FrmMain.treeview_queue,node);
  end;
  end;
  except
  end;
  end;
}{
  function tthread_upload.xqueued_in_listview(listview:tcomettree; queued:precord_queued):pCmtVnode;
  var
  node:pCmtVnode;
  i:integer;
  data:precord_queued;
  begin
  result:=nil;
  try
  nodE:=nil;
  i:=0;
  repeat
  if i=0 then node:=listview.getfirst
  else node:=listview.getnext(node);
  if node=nil then break;
  inc(i);
  data:=listview.getdata(node);
  if data^.ip=queued^.ip then
  if data^.port=queued^.port then
  if data^.crcnomefile=queued^.crcnomefile then
  if data^.nomefile=queued^.nomefile then begin
  result:=node;
  exit;
  end;
  until (not true);
  except
  end;
  end;
}
function tthread_upload.xqueued_trova_queued(ip: cardinal; port: word;
  crc: word; nomefile: string): precord_queued;
var
  i: integer;
  queued: precord_queued;
begin
  result := nil;
  try
    for i := 0 to lista_queued.count - 1 do
    begin
      queued := lista_queued[i];
      if queued^.ip = ip then
        if queued^.port = port then
          if queued^.crcnomefile = crc then
            if queued^.nomefile = nomefile then
            begin
              result := queued;
              exit;
            end;
    end;
  except
  end;
end;
procedure tthread_upload.xqueued_delete_queued_user(ip: cardinal; port: word;
  crc: word; nomefile: string);
var
  i: integer;
  queued: precord_queued;
  // cancel:boolean;
begin
  // cancel:=false;
  try
    for i := 0 to lista_queued.count - 1 do
    begin
      queued := lista_queued[i];
      if queued^.ip = ip then
        if queued^.port = port then
          if queued^.crcnomefile = crc then
            if queued^.nomefile = nomefile then
            begin
              queued^.nomefile := '';
              queued^.user := '';
              queued^.his_agent := '';
              lista_queued.delete(i);
              FreeMem(queued, sizeof(record_queued));
              // cancel:=true;
              break;
            end;
    end;
  except
  end;
  // if cancel then synchronize(update_statusbar_1);
end;
function tthread_upload.accept_countfromip(const ip: string): integer;
var
  i: integer;
  sock: ttcpblocksocket;
begin
  result := 0;
  for i := 0 to lista_sockets_accepted.count - 1 do
  begin
    sock := lista_sockets_accepted[i];
    if sock.ip = ip then
      inc(result);
  end;
end;
procedure tthread_upload.BindUdpSocket;
var
  sin: TVarSin;
begin
  if UDP_Socket <> INVALID_SOCKET then
    exit;
  FillChar(sin, sizeof(sin), 0);
  sin.sin_family := AF_INET;
  sin.sin_port := synsock.htons(vars_global.myport + 1);
  // myport already used by threadDHT
  sin.sin_addr.s_addr := 0;
  UDP_Socket := synsock.socket(PF_INET, integer(SOCK_DGRAM), IPPROTO_UDP);
  synsock.Bind(UDP_Socket, @sin, SizeOfVarSin(sin));
    end;
end.
